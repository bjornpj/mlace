## src/agents/os_agent.py
import re
import json  # Ensure this is imported
import subprocess
from src.agents.individual_agent import IndividualAgent

class OSAgent(IndividualAgent):
    def __init__(self, name, llm_interface):
        super().__init__(name, llm_interface)
        
    def perform_task(self, task):
        """
        Handles tasks requiring OS-level operations. Executes commands generated by the LLM.
        """
        task_description = task if isinstance(task, str) else task.get("description", "No description provided")
        self.communicate(f"Received task: {task_description}", level="INFO")

        prompt = f"""
        You are an OS Agent capable of solving tasks using Python, Shell or Cmd on Win11 OS.
        Analyze the following task and generate the appropriate command or script to execute it programmatically.

        Task: {task_description}

        Respond strictly in JSON format:
        {{
            "command_type": "python|shell|cmd",
            "command": "The command or script to execute the task",
            "remarks": "Explanation of the command if needed"
        }}
        """
        try:
            response = self.llm_interface.query(prompt)
            raw_response = response["message"]["content"].strip()
            self.communicate(f"Raw response from LLM: {raw_response}", level="DEBUG")

            # Sanitize and parse the response
            sanitized_response = self.sanitize_response(raw_response)
            if not sanitized_response or not isinstance(sanitized_response, dict):
                raise ValueError("Sanitized response is empty or invalid.")

            # Extract command details
            command_type = sanitized_response.get("command_type")
            command = sanitized_response.get("command")
            remarks = sanitized_response.get("remarks", "No remarks provided.")

            # Fix incorrect command types
            if command_type == "python" and not self.is_valid_python(command):
                self.communicate(f"Invalid Python command detected. Switching to default Python command.", level="WARNING")
                command = "import datetime; print(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'))"

            if command_type == "shell" or command_type == "cmd":
                command = self.fix_escape_sequences(command)

            self.communicate(f"Generated command: {command} ({command_type})", level="INFO")

            # Execute the command
            if command_type == "python":
                old_stdout = sys.stdout  # Define `old_stdout` before the try block
                sys.stdout = io.StringIO()  # Redirect stdout to capture execution output

                try:
                    exec(command, globals())  # Execute the command

                    # Retrieve the execution result
                    output = sys.stdout.getvalue().strip()
                except Exception as e:
                    output = f"Error: {e}"
                    self.communicate(f"Python command execution failed: {e}", level="ERROR")
                finally:
                    sys.stdout = old_stdout  # Restore stdout no matter what

                self.communicate(f"Python command executed successfully. Output: {output}", level="INFO")
                return {
                    "task": task_description,
                    "status": "completed" if "Error" not in output else "failed",
                    "quality": 100 if "Error" not in output else 0,
                    "result": output if output else "Python command executed with no output.",
                    "remarks": remarks
                }            
            elif command_type in ["shell", "cmd"]:
                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                output = result.stdout.strip()
                error = result.stderr.strip()
                if result.returncode == 0:
                    self.communicate(f"Command executed successfully. Output: {output}", level="INFO")
                    return {
                        "task": task_description,
                        "status": "completed",
                        "quality": 100,
                        "result": output,
                        "remarks": remarks
                    }
                else:
                    self.communicate(f"Command failed. Error: {error}", level="ERROR")
                    return {
                        "task": task_description,
                        "status": "failed",
                        "quality": 0,
                        "result": None,
                        "remarks": error
                    }
            else:
                self.communicate("Unsupported command type.", level="ERROR")
                return {
                    "task": task_description,
                    "status": "failed",
                    "quality": 0,
                    "result": None,
                    "remarks": "Unsupported command type."
                }
        except Exception as e:
            self.communicate(f"Error processing task '{task_description}': {e}", level="ERROR")
            return {
                "task": task_description,
                "status": "failed",
                "quality": 0,
                "result": None,
                "remarks": f"Exception occurred: {e}"
            }

    def is_valid_python(self, command):
        """
        Checks if the provided command is valid Python code.
        """
        try:
            compile(command, "<string>", "exec")
            return True
        except SyntaxError:
            return False

    def fix_escape_sequences(self, command):
        """
        Fixes incorrect escape sequences in shell and cmd commands.
        """
        # Replace incorrect "\%" with "%"
        command = re.sub(r'\\%', '%', command)
        
        # Ensure proper formatting for Windows CMD (double up %% for batch)
        if "cmd" in command:
            command = command.replace("%", "%%")
        
        return command